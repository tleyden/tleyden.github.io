<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | Seven Story Rabbit Hole]]></title>
  <link href="http://tleyden.github.io/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://tleyden.github.io/"/>
  <updated>2020-06-28T11:53:54-07:00</updated>
  <id>http://tleyden.github.io/</id>
  <author>
    <name><![CDATA[Traun Leyden]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Running PostgreSQL in Docker]]></title>
    <link href="http://tleyden.github.io/blog/2017/06/14/running-postgresql-in-docker/"/>
    <updated>2017-06-14T08:01:00-07:00</updated>
    <id>http://tleyden.github.io/blog/2017/06/14/running-postgresql-in-docker</id>
    <content type="html"><![CDATA[<p>This walks you through:</p>

<ol>
<li>Running Postgres locally in a docker container using docker networking (rather than the deprecated container links functionality that is mentioned in the <a href="https://hub.docker.com/_/postgres/">Postgres Docker instructions</a>.</li>
<li>Deploying to Docker Cloud</li>
</ol>


<h1>Basic Postgres container with docker networking</h1>

<h2>Create a user defined network</h2>

<p><code>
$ docker network create --driver bridge postgres-network
</code></p>

<h2>Launch Postgres in that network</h2>

<p>The main parameter you will need to provide to postgres is a root db password.  Replace <code>*********</code> with a good password and run this command:</p>

<p><code>
$ docker run --name postgres1 --network postgres-network -e POSTGRES_PASSWORD=********* -d postgres
</code></p>

<h2>Launch psql and connect to Postgres</h2>

<p>```
$ docker run -it &mdash;rm &mdash;network postgres-network postgres psql -h postgres1 -U postgres
Password for user postgres: <enter password used earlier>
psql (9.6.3)
Type &ldquo;help&rdquo; for help.</p>

<p>postgres=#
```</p>

<p>You now have a working postgres database server.</p>

<h1>Using a mounted volume for persistence</h1>

<p>When running postgres under docker, most likely want to persist the database files on the host, rather than having them in the container.</p>

<p>First, remove the previous container with:</p>

<p><code>
$ docker stop postgres1 &amp;&amp; docker rm postgres1
</code></p>

<p>Go into the <code>/tmp</code> directory:</p>

<p><code>
$ cd /tmp
</code></p>

<p>Launch a container and use <code>/tmp/pgdata</code> as the host directory to mount as a volume mount, which will be mounted in the container in <code>/var/lib/postgresql/data</code>, which is the default location where Postgres stores it&rsquo;s data.  The <code>/tmp/pgdata</code> directory will be created on the host if it doesn&rsquo;t already exist.</p>

<p><code>
$ docker run --name postgres1 --network postgres-network -v /tmp/pgdata:/var/lib/postgresql/data -e POSTGRES_PASSWORD=*************** -d postgres
</code></p>

<p>List the contents of <code>/tmp/pgdata</code> and you should see several Postgres files:</p>

<p><code>
$ ls pgdata/
PG_VERSION      pg_hba.conf     pg_serial       pg_twophase ...
</code></p>

<h1>Launch phppgadmin Container</h1>

<h2>First create a user</h2>

<p><code>
$ docker run -it --rm --network postgres-network postgres /bin/bash
</code></p>

<p>Now you will be in a shell inside the docker container</p>

<p>```</p>

<h1>createuser testuser -P &mdash;createdb -h postgres1 -U postgres</h1>

<p>Enter password for new role: <strong><strong><strong>*
Enter it again: </strong></strong></strong>
Password: <enter postgres password from earlier>
```</p>

<h2>Launch pgpadmin</h2>

<p><code>
 $ docker run --name phppgadmin --network postgres-network -ti -d -p 8080:80 -e DB_HOST=postgres1 keepitcool/phppgadmin
</code></p>

<h2>Login</h2>

<p>In your browser, open <a href="http://localhost:8080/">http://localhost:8080/</a> and you should see the phpadmin login screen:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/phppgadmin.png" alt="loginscreen" /></p>

<p>Login with user/pass credentials created earlier:</p>

<ul>
<li><strong>username</strong>: <code>testuser</code></li>
<li><strong>password</strong>: <code>**********</code></li>
</ul>


<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/phpadmin_post_login.png" alt="postlogin" /></p>

<h1>Deploying to Docker Cloud</h1>

<p>Security warning!  This is not a secure deployment and it&rsquo;s not recommended to run this in production without a thorough audit by a security specialist.</p>

<h2>Deploy Stack</h2>

<p>Create a new stack and paste it into the box</p>

<p>```
postgres-server:
  autoredeploy: true
  environment:</p>

<pre><code>- POSTGRES_PASSWORD=***************
</code></pre>

<p>  image: &lsquo;postgres:latest&rsquo;
  volumes:</p>

<pre><code>- '/var/lib/postgresql/data:/var/lib/postgresql/data'
</code></pre>

<p>phppgadmin:
  autoredeploy: true
  environment:</p>

<pre><code>- DB_HOST=postgres-server
</code></pre>

<p>  image: &lsquo;keepitcool/phppgadmin:latest&rsquo;
  ports:</p>

<pre><code>- '8085:80'
</code></pre>

<p>```</p>

<p>For example:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/docker_cloud_create_stack.png" alt="Docker Cloud" /></p>

<h2>Create user</h2>

<p>Find the postgres-server container and hit the <strong>Terminal</strong> menu to get a shell on that container.</p>

<p>Enter:</p>

<p>```</p>

<h1>createuser testuser -P &mdash;createdb -h localhost -U postgres</h1>

<p>Enter password for new role: <strong><strong><strong><em>
Enter it again: </em></strong></strong></strong>**
```</p>

<h2>Login to Web UI</h2>

<p>Find the phppgadmin service in the Docker Cloud Web UI, and look for the service endpoint, which should look something like this:</p>

<p><a href="http://phppgadmin.postgres.071a32d40.svc.dockerapp.io:8085/">http://phppgadmin.postgres.071a32d40.svc.dockerapp.io:8085/</a></p>

<p>Login with user/pass credentials created earlier:</p>

<ul>
<li><strong>username</strong>: <code>testuser</code></li>
<li><strong>password</strong>: <code>**********</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress under Docker]]></title>
    <link href="http://tleyden.github.io/blog/2016/02/06/octopress-under-docker/"/>
    <updated>2016-02-06T05:38:00-08:00</updated>
    <id>http://tleyden.github.io/blog/2016/02/06/octopress-under-docker</id>
    <content type="html"><![CDATA[<p>I&rsquo;m setting up a clean install of El Capitan, and want to get my Octopress blog going.  However, I don&rsquo;t want to install it <em>directly</em> on my OSX workstation &mdash; I want to have it <em>contained</em> in a docker container.</p>

<h2>Install Docker</h2>

<p>That&rsquo;s beyond the scope of this blog post, but what I ended up doing on my new OSX installation was to:</p>

<ul>
<li>Install VirtualBox 5.0.14</li>
<li>Install <a href="https://www.docker.com/products/docker-toolbox">docker toolbox</a></li>
</ul>


<h2>Run tleyden5iwx/octopress</h2>

<p><code>
$ docker run -itd -v ~/Documents/blog/:/blog tleyden5iwx/octopress /bin/bash
</code></p>

<p>What&rsquo;s in <code>~/Documents/blog/</code>?  Basically, the octopress instance I&rsquo;d setup as described in <a href="http://tleyden.github.io/blog/2013/09/07/octopress-setup-part-i/">Octopress Setup Part I</a>.</p>

<h2>Bundle install</h2>

<p>From inside the docker container:</p>

<p>```</p>

<h1>cd /blog/octopress</h1>

<h1>bundle install</h1>

<p>```</p>

<h2>Edit a blog post</h2>

<p>On OSX, open up <code>~/Documents/blog/source/_posts/path-to-post</code> and make some minor edits</p>

<h2>Push source</h2>

<p>```</p>

<h1>git push origin source</h1>

<p>Username for &lsquo;<a href="https://github.com">https://github.com</a>&rsquo;: [enter your username]
Password for &lsquo;<a href="https://username@github.com">https://username@github.com</a>&rsquo;: [enter your password]
```</p>

<h2>Generate and push to master</h2>

<p><strong>Attempt 1</strong></p>

<p>```</p>

<h1>rake generate</h1>

<p>rake aborted!
Gem::LoadError: You have already activated rake 10.4.2, but your Gemfile requires rake 0.9.6. Using bundle exec may solve this.
/blog/octopress/Rakefile:2:in `<top (required)>&lsquo;
(See full trace by running task with &mdash;trace) <br/>
```</p>

<p>I have no idea why this is happening, but I just conceded defeat against these ruby weirdisms, wished I was using Go (and thought about converting my blog to Hugo), and took their advice and prefixed every command thereafter with <code>bundle exec</code>.</p>

<p><strong>Attempt 2</strong></p>

<p>```</p>

<h1>bundle exec rake generate &amp;&amp; bundle exec rake deploy</h1>

<p>Username for &lsquo;<a href="https://github.com">https://github.com</a>&rsquo;: [enter your username]
Password for &lsquo;<a href="https://username@github.com">https://username@github.com</a>&rsquo;: [enter your password]
```</p>

<p>Success!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up Uniqush with APNS]]></title>
    <link href="http://tleyden.github.io/blog/2016/02/03/setting-up-uniqush-with-apns/"/>
    <updated>2016-02-03T08:47:00-08:00</updated>
    <id>http://tleyden.github.io/blog/2016/02/03/setting-up-uniqush-with-apns</id>
    <content type="html"><![CDATA[<p>This walks you through running <a href="http://uniqush.org/index.html">Uniqush</a> in the cloud (under Docker) and setting up an iOS app to receive messages via APNS (Apple Push Notification Service).</p>

<h2>Run Uniqush under Docker</h2>

<h3>Install Docker components</h3>

<ul>
<li><a href="https://docs.docker.com/v1.8/installation/mac/">Install docker</a></li>
<li><a href="https://docs.docker.com/compose/install/">Install docker-compose</a></li>
</ul>


<h3>Config</h3>

<ul>
<li><code>mkdir -p volumes/uniqush</code></li>
<li><code>wget https://git.io/vgSYM -O volumes/uniqush/uniqush-push.conf</code></li>
</ul>


<p>Security note: the above config has Uniqush listening on all interfaces, but depending on your setup you probably want to change that to <code>localhost</code> or something more restrictive.</p>

<h3>Docker compose file</h3>

<p>Copy and paste this content into <code>docker-compose.yml</code></p>

<p>```</p>

<p>version: &lsquo;2&rsquo;</p>

<p>services:
  uniqush:</p>

<pre><code>container_name: uniqush
ports:
  - "9898:9898"
image: tleyden5iwx/uniqush
entrypoint: uniqush-push
links:
  - redis
volumes:
  - ~/docker/volumes/uniqush/uniqush-push.conf:/etc/uniqush/uniqush-push.conf
</code></pre>

<p>  redis:</p>

<pre><code>container_name: redis
image: redis
</code></pre>

<p>```</p>

<h3>Start docker containers</h3>

<p><code>
$ docker compose up -d
</code></p>

<h3>Verify Uniqush is running</h3>

<p>Run this <code>curl</code> command outside of the docker container to verify that Uniqush is responding to HTTP requests:</p>

<p><code>
$ curl localhost:9898/version
uniqush-push 1.5.2
</code></p>

<h2>Create APNS certificate</h2>

<p>In my case, I already had an app id for my app (<code>com.couchbase.todolite</code>), but push notifications are not enabled, so I needed to enable them:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/todolite_app_settings.png" alt="screenshot" /></p>

<p>Create a new push cert:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/create_new_push_cert.png" alt="screenshot" /></p>

<p>Choose the correct app id:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/choose_app_id.png" alt="screenshot" /></p>

<p>Generate CSR according to instructions in keychain:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/create_csr.png" alt="screenshot" /></p>

<p>This will save a CSR on your file system, and the next wizard step will ask you to upload this CSSR and generate the certificate.  Now you can download it:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/download_cert.png" alt="screenshot" /></p>

<p>Double click the downloaded cert and it will be added to your keychain.</p>

<p>This is where I got a bit confused, since I had to <em>also</em> download the cert from the app id section &mdash; go to the app id and hit &ldquo;Edit&rdquo;, then download the cert and double click it to add to your keychain.  (I&rsquo;m confused because I thought these were the same certs and this second step felt redundant)</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/download_app_id_cert.png" alt="screenshot" /></p>

<h2>Create and use provisioning profile</h2>

<p>Go to the <strong>Provisioning Profiles / Development</strong> section and hit the &ldquo;+&rdquo; button:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/create_provisioning_profile.png" alt="screenshot" /></p>

<p>Choose all certs and all devices, and then give your provisioning profile an easy to remember name.</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/create_provisioning_profile_2.png" alt="screenshot" /></p>

<p>Download this provisioning profile and double click it to install it.</p>

<p>In xcode under <strong>Build Settings</strong>, choose this provisioning profile:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/xcode_choose_provisioning_profile.png" alt="screenshot" /></p>

<h2>Register for push notifications in your app</h2>

<p>Add the following code to your <code>didFinishLaunchingWithOptions:</code>:</p>

<p>```
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions {</p>

<pre><code>// Register for push notifications
if ([application respondsToSelector:@selector(isRegisteredForRemoteNotifications)])
{
    // iOS 8 Notifications
    [application registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:(UIUserNotificationTypeSound | UIUserNotificationTypeAlert | UIUserNotificationTypeBadge) categories:nil]];

    [application registerForRemoteNotifications];
}
else
{
    // iOS &lt; 8 Notifications
    [application registerForRemoteNotificationTypes:
     (UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound)];
}

// rest of your code goes here ...
</code></pre>

<p>}
```</p>

<p>And the following callback methods which will be called if remote notification is successful:</p>

<p>```
&ndash; (void)application:(UIApplication <em>)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData </em>)deviceToken
{</p>

<pre><code>NSString *deviceTokenStr = [NSString stringWithFormat:@"%@",deviceToken];
NSLog(@"didRegisterForRemoteNotificationsWithDeviceToken, Device token: %@", deviceTokenStr);

NSString* deviceTokenCleaned = [[[[deviceToken description]
                                  stringByReplacingOccurrencesOfString: @"&lt;" withString: @""]
                                 stringByReplacingOccurrencesOfString: @"&gt;" withString: @""]
                                stringByReplacingOccurrencesOfString: @" " withString: @""];

 NSLog(@"didRegisterForRemoteNotificationsWithDeviceToken, Cleaned device token token: %@", deviceTokenCleaned);
</code></pre>

<p>}
```</p>

<p>and this callback which will be called if it&rsquo;s not unsuccessful:</p>

<p>```
&ndash; (void)application:(UIApplication <em>)app didFailToRegisterForRemoteNotificationsWithError:(NSError </em>)err
{</p>

<pre><code>NSString *str = [NSString stringWithFormat: @"Error: %@", err];
NSLog(@"Error registering device token.  Push notifications will not work%@", str);
</code></pre>

<p>}</p>

<p>```</p>

<p>If you now run this app on a simulator, you can expect an error like <code>Error registering device token.  Push notifications will not workError</code>.</p>

<p>Run the app on a device you should see a popup dialog in the app asking if it&rsquo;s OK to receive push notifications, and the following log messages in the xcode console:</p>

<p><code>
didRegisterForRemoteNotificationsWithDeviceToken, Device token: &lt;281c8710 1b029fdb 16c8e134 39436336 116001ce bf6519e6 8edefab5 23dab4e9&gt;
didRegisterForRemoteNotificationsWithDeviceToken, Cleaned device token token: 281c87101b029fdb16c8e13439436336116001cebf6519e68edefab523dab4e9
</code></p>

<h2>Export APNS keys to .PEM format</h2>

<p>Open keychain, select the <code>login</code> keychain and the <code>My Certificates</code> category:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/export_cert_keychain.png" alt="screenshot" /></p>

<ul>
<li>Right click on the certificate (not the private key) “Apple Development Push Services: (your app id)”</li>
<li>Choose Export “Apple Development Push Services: (your app id)″.</li>
<li>Save this as <code>apns-prod-cert.p12</code> file somewhere you can access it.</li>
<li>When it prompts you for a password, leave it blank (or add one if you want, but this tutorial will assume it was left blank)</li>
<li>Repeat with the private key (in this case, TodoLite Push Notification Cert) and save it as <code>apns-prod-key.p12</code>.</li>
</ul>


<p>Now they need to be converted from <code>.p12</code> to <code>.pem</code> format.</p>

<p><code>
$ openssl pkcs12 -clcerts -nokeys -out apns-prod-cert.pem -in apns-prod-cert.p12
Enter Import Password: &lt;return&gt;
MAC verified OK
</code></p>

<p><code>
$ openssl pkcs12 -nocerts -out apns-prod-key.pem -in apns-prod-key.p12
Enter Import Password:
MAC verified OK
Enter PEM pass phrase: hello &lt;return&gt;
</code></p>

<p>Remove the PEM passphrase:</p>

<p><code>
$ openssl rsa -in apns-prod-key.pem -out apns-prod-key-noenc.pem
Enter pass phrase for apns-prod-key.pem: hello
writing RSA key
</code></p>

<h2>Add PEM files to Uniqush docker container</h2>

<p>When you call the Uniqush REST API to add a Push Service Provider, it expects to find the PEM files on it&rsquo;s local file system.  Use the following commands to get these files into the running container in the <code>/tmp</code> directory:</p>

<p><code>
$ `container=$(docker ps | grep -i uniqush-push | awk '{print $1}')`
$ docker cp /tmp/apns-prod-cert.pem $container:/tmp/apns-prod-cert.pem
$ docker cp /tmp/apns-prod-key-noenc.pem $container:/tmp/apns-prod-key-noenc.pem
</code></p>

<h2>Create APNS provider in Uniqush via REST API</h2>

<p>```
$ curl -v <a href="http://localhost:9898/addpsp">http://localhost:9898/addpsp</a> -d service=myservice \</p>

<pre><code>                       -d pushservicetype=apns \
                   -d cert=/tmp/apns-prod-cert.pem \
                   -d key=/tmp/apns-prod-key-noenc.pem \
                   -d sandbox=true
</code></pre>

<p>```</p>

<p>(Note: I&rsquo;m using a development cert, but if this was a distribution cert you&rsquo;d want to use <code>sandbox=false</code>)</p>

<p>You should get a <code>200 OK</code> response with:</p>

<p><code>
[AddPushServiceProvider][Info] 2016/02/03 20:35:29 From=24.23.246.59:59447 Service=myservice PushServiceProvider=apns:9f49c9c618c97bebe21bea159d3c7a8577934bdf00 Success!
</code></p>

<h2>Add Uniqush subscriber</h2>

<p>Using the cleaned up device token from the previous step <code>281c87101b029fdb16c8e13439436336116001cebf6519e68edefab523dab1e9</code>, create a subscriber with the name <code>mytestsubscriber</code> via:</p>

<p>```
$ curl -v <a href="http://localhost:9898/subscribe">http://localhost:9898/subscribe</a> -d service=myservice \</p>

<pre><code>                                         -d subscriber=mytestsubscriber \
                     -d pushservicetype=apns \
                     -d devtoken=281c87101b029fdb16c8e13439436336116001cebf6519e68edefab523dab1e9 
</code></pre>

<p>```</p>

<p>You should receive a <code>200 OK</code> response with:</p>

<p><code>
[Subscribe][Info] 2016/02/03 20:43:21 From=24.23.246.59:60299 Service=myservice Subscriber=mytestsubscriber PushServiceProvider=apns:9f49c9c618c97bebe21bea159d3c7a8577934bdf00 DeliveryPoint=apns:2cbecd0798cc6731d96d5b0fb01d813c7c9a83af00 Success!
</code></p>

<h2>Push a test message</h2>

<p>The moment of truth!</p>

<p>First, you need to either <strong>background your app</strong> by pressing the home button, or add <a href="https://gist.github.com/tleyden/97434117ad53757106ad">some code like this</a> so that an alert will be shown if the app is foregrounded.</p>

<p>```
$ curl -v <a href="http://localhost:9898/push">http://localhost:9898/push</a> -d service=myservice \</p>

<pre><code>                                    -d subscriber=mytestsubscriber \
                -d msg=HelloWorld
</code></pre>

<p>```</p>

<p>You should get a <code>200 OK</code> response with:</p>

<p><code>
[Push][Info] 2016/02/03 20:46:08 RequestId=56b26710-INbW8UWMUONtH8Ttddd2Qg== From=24.23.246.59:60634 Service=myservice NrSubscribers=1 Subscribers="[mytestsubscriber]"
[Push][Info] 2016/02/03 20:46:09 RequestID=56b26710-INbW8UWMUONtH8Ttddd2Qg== Service=myservice Subscriber=mytestsubscriber PushServiceProvider=apns:9f49c9c618c97bebe21bea159d3c7a8577934bdf00 DeliveryPoint=apns:2cbecd0798cc6731d96d5b0fb01d813c7c9a83af MsgId=apns:apns:9f49c9c618c97bebe21bea159d3c7a8577934bdf-1 Success!
</code></p>

<p>And a push notification on the device!</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/push_notification_device.png" alt="screenshot" /></p>

<h2>References</h2>

<ul>
<li><a href="http://uniqush.org/documentation/usage.html">Uniqush docs</a></li>
<li><a href="http://quickblox.com/developers/How_to_create_APNS_certificates">How to create APNS certificates</a></li>
<li><a href="https://blog.serverdensity.com/how-to-renew-your-apple-push-notification-push-ssl-certificate/">How to renew your Apple Push Notification Push SSL Certificate</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Neural Style on an AWS GPU instance]]></title>
    <link href="http://tleyden.github.io/blog/2015/11/22/running-neural-style-on-an-aws-gpu-instance/"/>
    <updated>2015-11-22T11:02:00-08:00</updated>
    <id>http://tleyden.github.io/blog/2015/11/22/running-neural-style-on-an-aws-gpu-instance</id>
    <content type="html"><![CDATA[<p>These instructions will walk you through getting <a href="https://github.com/jcjohnson/neural-style">neural-style</a> up and running on an AWS GPU instance.</p>

<h2>Spin up CUDA-enabled AWS instance</h2>

<p>Follow these instructions to <a href="http://tleyden.github.io/blog/2015/11/22/cuda-7-dot-5-on-aws-gpu-instance-running-ubuntu-14-dot-04/">install CUDA 7.5 on AWS GPU Instance Running Ubuntu 14.04</a>.</p>

<h2>SSH into AWS instance</h2>

<p><code>
$ ssh ubuntu@&lt;instance-ip&gt;
</code></p>

<h2>Install Docker</h2>

<p><code>
$ sudo apt-get update &amp;&amp; sudo apt-get install curl
$ curl -sSL https://get.docker.com/ | sh
</code></p>

<p>As the post-install message suggests, enable docker for non-root users:</p>

<p><code>
$ sudo usermod -aG docker ubuntu
</code></p>

<p>Verify correct install via:</p>

<p><code>
$ sudo docker run hello-world
</code></p>

<h2>Mount GPU devices</h2>

<p><strong>Mount</strong></p>

<p><code>
$ cd /usr/local/cuda/samples/1_Utilities/deviceQuery
$ sudo make
$ sudo ./deviceQuery
</code></p>

<p>You should see something <a href="https://gist.github.com/tleyden/58ab2eedebc9529edb76">like this</a>:</p>

<p>```
./deviceQuery Starting&hellip;</p>

<p> CUDA Device Query (Runtime API) version (CUDART static linking)</p>

<p>Detected 1 CUDA Capable device(s)</p>

<p>Device 0: &ldquo;GRID K520&rdquo;
  CUDA Driver Version / Runtime Version          6.5 / 6.5
  &hellip; snip &hellip;</p>

<p>deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 6.5, CUDA Runtime Version = 6.5, NumDevs = 1, Device0 = GRID K520
Result = PASS
```</p>

<p><strong>Verify: Find all your nvidia devices</strong></p>

<p><code>
$ ls -la /dev | grep nvidia
</code></p>

<p>You should see:</p>

<p><code>
crw-rw-rw-  1 root root    195,   0 Oct 25 19:37 nvidia0
crw-rw-rw-  1 root root    195, 255 Oct 25 19:37 nvidiactl
crw-rw-rw-  1 root root    251,   0 Oct 25 19:37 nvidia-uvm
</code></p>

<h2>Start Docker container</h2>

<p><code>
$ export DOCKER_NVIDIA_DEVICES="--device /dev/nvidia0:/dev/nvidia0 --device /dev/nvidiactl:/dev/nvidiactl --device /dev/nvidia-uvm:/dev/nvidia-uvm"
$ sudo docker run -ti $DOCKER_NVIDIA_DEVICES kaixhin/cuda-torch /bin/bash
</code></p>

<h2>Re-install CUDA 7.5 in the Docker container</h2>

<p>As <a href="https://groups.google.com/d/msg/torch7/yCSNIzW590M/Af7CHXEdDQAJ">reported in the Torch7 Google Group</a> and in <a href="https://github.com/Kaixhin/dockerfiles/issues/6">Kaixhin/dockerfiles</a>, there is an API version mismatch with the docker container and the host&rsquo;s version of CUDA.</p>

<p>The workaround is to re-install CUDA 7.5 via:</p>

<p>```
$ wget <a href="http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1404/x86_64/cuda-repo-ubuntu1404_7.5-18_amd64.deb">http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1404/x86_64/cuda-repo-ubuntu1404_7.5-18_amd64.deb</a>
$ sudo dpkg -i cuda-repo-ubuntu1404_7.5-18_amd64.
deb
$ sudo apt-get update
$ sudo apt-get upgrade -y
$ sudo apt-get install -y opencl-headers build-essential protobuf-compiler \</p>

<pre><code>libprotoc-dev libboost-all-dev libleveldb-dev hdf5-tools libhdf5-serial-dev \
libopencv-core-dev  libopencv-highgui-dev libsnappy-dev libsnappy1 \
libatlas-base-dev cmake libstdc++6-4.8-dbg libgoogle-glog0 libgoogle-glog-dev \
libgflags-dev liblmdb-dev git python-pip gfortran
</code></pre>

<p>$ sudo apt-get clean
$ sudo apt-get install -y linux-image-extra-<code>uname -r</code> linux-headers-<code>uname -r</code> linux-image-<code>uname -r</code>
$ sudo apt-get install -y cuda
```</p>

<h2>Verify CUDA inside docker container</h2>

<p>Running:</p>

<p><code>
$ nvidia-smi
</code></p>

<p>Should show info about the GPU driver and not return any errors.</p>

<p>Running this torch command:</p>

<p><code>
$ th -e "require 'cutorch'; require 'cunn'; print(cutorch)"
</code></p>

<p>Should produce this output:</p>

<p><code>
{
  getStream : function: 0x4054b760
  getDeviceCount : function: 0x408bca58
  .. etc
}
</code></p>

<h2>Install neural-style</h2>

<p>The following should be run <strong>inside</strong> the docker container:</p>

<p><code>
$ apt-get install -y wget libpng-dev libprotobuf-dev protobuf-compiler
$ git clone --depth 1 https://github.com/jcjohnson/neural-style.git
$ /root/torch/install/bin/luarocks install loadcaffe
</code></p>

<p><strong>Download models</strong></p>

<p><code>
$ cd neural-style
$ sh models/download_models.sh
</code></p>

<h2>Run neural style</h2>

<p>First, grab a few images to test with</p>

<p><code>
$ mkdir images
$ wget https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/1280px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg -O images/vangogh.jpg
$ wget http://exp.cdn-hotels.com/hotels/1000000/10000/7500/7496/7496_42_z.jpg -O images/hotel_del_coronado.jpg
</code></p>

<p>Run it:</p>

<p><code>
$ th neural_style.lua -style_image images/vangogh.jpg -content_image images/hotel_del_coronado.jpg
</code></p>

<h2>CuDNN (optional)</h2>

<p>CuDNN can potentially speed things up.</p>

<p><a href="https://developer.nvidia.com/cudnn">download cuDNN</a></p>

<p>Install via:</p>

<p><code>
tar -xzvf cudnn-7.0-linux-x64-v3.0-prod.tgz
cd cuda/
sudo cp lib64/libcudnn* /usr/local/cuda-7.5/lib64/
sudo cp include/cudnn.h /usr/local/cuda-7.5/include
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-7.5/lib64/
</code></p>

<p>Install the torch bindings for cuDNN:</p>

<p><code>
luarocks install cudnn
</code></p>

<h2>References</h2>

<ul>
<li><a href="https://github.com/jcjohnson/neural-style/blob/master/INSTALL.md">Neural-Style INSTALL.md</a></li>
<li>ami-84c787ee &mdash; this AMI has everything pre-installed, however it is installed on the host rather than under docker, which was due to time constraints.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Couchbase Server under Joyent Triton]]></title>
    <link href="http://tleyden.github.io/blog/2015/05/05/running-couchbase-server-under-docker-on-joyent/"/>
    <updated>2015-05-05T09:31:00-07:00</updated>
    <id>http://tleyden.github.io/blog/2015/05/05/running-couchbase-server-under-docker-on-joyent</id>
    <content type="html"><![CDATA[<p>Joyent has recently announced their new Triton Docker container hosting service.  There are several advantages of running Docker containers on Triton over a more traditional cloud hosting platform:</p>

<ul>
<li><p>Better performance since there is no hardware level virtualization overhead.  Your containers run on bare-metal.</p></li>
<li><p>Simplified networking between containers.  Each container gets its own private (and optionally public) ip address.</p></li>
<li><p>Hosts are abstracted away &mdash; you just deploy into the &ldquo;container cloud&rdquo;, and don&rsquo;t care which host your container is running on.</p></li>
</ul>


<p>For more details, check out Bryan Cantrill&rsquo;s talk about <a href="https://www.joyent.com/developers/videos/docker-and-the-future-of-containers-in-production">Docker and the Future of Containers in Production</a>.</p>

<p>Let&rsquo;s give it a spin with a &ldquo;hello world&rdquo; container, and then with a cluster of Couchbase servers.</p>

<h2>Sign up for a Joyent account</h2>

<p><a href="https://www.joyent.com/lp/preview">Follow the signup instructions on the Joyent website</a></p>

<p>You will also need to add your SSH key to your account.</p>

<h2>Install or Upgrade Docker</h2>

<p>If you don&rsquo;t have Docker installed already and you are on Ubuntu, run:</p>

<p><code>
$ curl -sSL https://get.docker.com/ | sh
</code></p>

<p>See <a href="https://docs.docker.com/installation/ubuntulinux/">install Docker on Ubuntu</a> for more details.</p>

<h2>Upgrade Docker client to 1.4.1 or later</h2>

<p>Check your version of Docker with:</p>

<p><code>
$ docker --version
Docker version 1.0.1, build 990021a
</code></p>

<p>If you are on a version before 1.4.1 (like I was), you can upgrade Docker via the <a href="https://github.com/boot2docker/osx-installer/releases">boot2docker installers</a>.</p>

<h2>Joyent + Docker setup</h2>

<p>Get the sdc-docker repo (sdc == Smart Data Center):</p>

<p><code>
$ git clone https://github.com/joyent/sdc-docker.git
</code></p>

<p>Perform setup via:</p>

<p><code>
$ cd sdc-docker
$  ./tools/sdc-docker-setup.sh -k 165.225.168.22 $ACCOUNT ~/.ssh/$PRIVATE_KEY_FILE
</code></p>

<p>Replace values as follows:</p>

<ul>
<li><strong>$ACCOUNT</strong>: you can get this by logging into the Joyent web ui and going to the Account menu from the pulldown in the top-right corner.  Find the <strong>Username</strong> field, and use that</li>
<li><strong>$PRIVATE_KEY_FILE</strong>: the name of the file where your private key is stored, typically this will be <code>id_rsa</code></li>
</ul>


<p>Run the command and you should see the following output:</p>

<p>```
Setting up Docker client for SDC using:</p>

<pre><code>CloudAPI:        https://165.225.168.22
Account:         &lt;your username&gt;
Key:             /home/ubuntu/.ssh/id_rsa
</code></pre>

<p>[..snip..]</p>

<p>Wrote certificate files to /home/ubuntu/.sdc/docker/<username></p>

<p>Docker service endpoint is: tcp://<generated ip>:2376</p>

<hr />

<p>Success. Set your environment as follows:</p>

<pre><code>export DOCKER_CERT_PATH=/home/ubuntu/.sdc/docker/&lt;username&gt;
export DOCKER_HOST=tcp://&lt;generated-ip&gt;:2376
alias docker="docker --tls"
</code></pre>

<p>Then you should be able to run &lsquo;docker info&rsquo; and see your account
name &lsquo;SDCAccount: <username>&rsquo; in the output.
```</p>

<p><strong>Export environment variables</strong></p>

<p>As the output above suggests, copy and paste the commands from the output.  Here&rsquo;s an example of what that will look like (but you should copy and paste from your command output, not the snippet below):</p>

<p><code>
$ export DOCKER_CERT_PATH=/home/ubuntu/.sdc/docker/&lt;username&gt;
$ export DOCKER_HOST=tcp://&lt;generated-ip&gt;:2376
$ alias docker="docker --tls"
</code></p>

<h2>Docker Hello World</h2>

<p>Let&rsquo;s spin up an Ubuntu docker image that says hello world.</p>

<p>Remember you&rsquo;re running the Docker client on your workstation, not in the cloud.  Here&rsquo;s an overview on what&rsquo;s going to be happening:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/joyent_container_hello_world.png" alt="diagram" /></p>

<p>To start the docker container::</p>

<p><code>
$ docker run --rm ubuntu:14.04 echo "Hello Docker World, from Joyent"
</code></p>

<p>You should see the following output:</p>

<p><code>
Unable to find image 'ubuntu:14.04' locally
Pulling repository library/ubuntu
...
Hello Docker World, from Joyent
</code></p>

<p>Also, since the <code>--rm</code> flag was passed, the container will have been removed after exiting.  You can verify this by running <code>docker ps -a</code>.  This is important because <strong>stopped containers incur charges on Joyent</strong>.</p>

<p>Congratulations!  You&rsquo;ve gotten a &ldquo;hello world&rdquo; Docker container running on Joyent.</p>

<h2>Run Couchbase Server containers</h2>

<p>Now it&rsquo;s time to run Couchbase Server.</p>

<p>To kick off three Couchbase Server containers, run:</p>

<p><code>``
$ for i in</code>seq 1 3`; do \</p>

<pre><code>  echo "Starting container $i"; \
  export container_$i=$(docker run --name couchbase-server-$i -d -P couchbase/server); \
</code></pre>

<p>  done
```</p>

<p>To confirm the containers are up, run:</p>

<p><code>
$ docker ps
</code></p>

<p>and you should see:</p>

<p><code>
CONTAINER ID        IMAGE                                       COMMAND             CREATED             STATUS              PORTS               NAMES
5bea8901814c        couchbase/server   "couchbase-start"   3 minutes ago       Up 2 minutes                            couchbase-server-1
bef1f2f32726        couchbase/server   "couchbase-start"   2 minutes ago       Up 2 minutes                            couchbase-server-2
6f4e2a1e8e63        couchbase/server   "couchbase-start"   2 minutes ago       Up About a minute                       couchbase-server-3
</code></p>

<p>At this point you will have environment variables defined with the container ids of each container.  You can check this by running:</p>

<p><code>
$ echo $container_1 &amp;&amp; echo $container_2 &amp;&amp; echo $container_3
21264e44d66b4004b4828b7ae408979e7f71924aadab435aa9de662024a37b0e
ff9fb4db7b304e769f694802e6a072656825aa2059604ba4ab4d579bd2e5d18d
0c6f8ca2951448e497d7e12026dcae4aeaf990ec51e047cf9d8b2cbdd9bd7668
</code></p>

<h3>Get public ip addresses of the containers</h3>

<p>Each container will have two IP addresses assigned:</p>

<ul>
<li>A public IP, accessible from anywhere</li>
<li>A private IP, only accessible from containers/machines in your Joyent account</li>
</ul>


<p>To get the public IP, we can use the Docker client.  (to get the private IP, you need to use the Joyent SmartDataCenter tools, which is described below)</p>

<p><code>``
$ container_1_ip=</code>docker inspect $container_1 | grep -i IPAddress | awk -F: &lsquo;{print $2}&rsquo; |  grep -oE &ldquo;\b([0-9]{1,3}.){3}[0-9]{1,3}\b&rdquo;<code>
$ container_2_ip=</code>docker inspect $container_2 | grep -i IPAddress | awk -F: &lsquo;{print $2}&rsquo; |  grep -oE &ldquo;\b([0-9]{1,3}.){3}[0-9]{1,3}\b&rdquo;<code>
$ container_3_ip=</code>docker inspect $container_3 | grep -i IPAddress | awk -F: &lsquo;{print $2}&rsquo; |  grep -oE &ldquo;\b([0-9]{1,3}.){3}[0-9]{1,3}\b&rdquo;`</p>

<p>```</p>

<p>You will now have the public IP addresses of each container defined in environment variables.  You can check that it worked via:</p>

<p><code>
$ echo $container_1_ip &amp;&amp; echo $container_2_ip &amp;&amp; echo $container_3_ip
165.225.185.11
165.225.185.12
165.225.185.13
</code></p>

<h3>Connect to Couchbase Web UI</h3>

<p>Open your browser to $container_1_ip:8091 and you should see:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/couchbase_cluster_setup.png" alt="Couchbase Welcome Screen" /></p>

<p>At this point, it&rsquo;s possible to setup the cluster by going to each Couchbase node&rsquo;s Web UI and following the Setup Wizard.  However, in case you want to automate this in the future, let&rsquo;s do this over the command line instead.</p>

<h3>Setup first Couchbase node</h3>

<p>Let&rsquo;s arbitrarily pick <strong>container_1</strong> as the first node in the cluster.  This node is special in the sense that other nodes will join it.</p>

<p>The following command will do the following:</p>

<ul>
<li>Set the Administrator&rsquo;s username and password to Administrator / password (you should change this)</li>
<li>Set the cluster RAM size to 600 MB</li>
</ul>


<p>Note: the <code>-u admin -p password</code> should be left as-is, since that is just passing in the default admin name and password for auth purposes.</p>

<p><code>
$ docker run --rm --entrypoint=/opt/couchbase/bin/couchbase-cli couchbase/server \
cluster-init -c $container_1_ip \
--cluster-init-username=Administrator \
--cluster-init-password=password \
--cluster-init-ramsize=600 \
-u admin -p password
</code></p>

<p>You should see a response like:</p>

<p><code>
SUCCESS: init 165.225.185.11
</code></p>

<h3>Create a default bucket</h3>

<p>A bucket is equivalent to a database in typical RDMS systems.</p>

<p><code>
$ docker run --rm --entrypoint=/opt/couchbase/bin/couchbase-cli couchbase/server \
bucket-create -c $container_1_ip:8091 \
--bucket=default \
--bucket-type=couchbase \
--bucket-port=11211 \
--bucket-ramsize=600 \
--bucket-replica=1 \
-u Administrator -p password
</code></p>

<p>You should see:</p>

<p><code>
SUCCESS: bucket-create
</code></p>

<h3>Add 2nd Couchbase node</h3>

<p>Add in the second Couchbase node with this command</p>

<p><code>
$ docker run --rm --entrypoint=/opt/couchbase/bin/couchbase-cli couchbase/server \
server-add -c $container_1_ip \
-u Administrator -p password \
--server-add $container_2_ip \
--server-add-username Administrator \
--server-add-password password
</code></p>

<p>You should see:</p>

<p><code>
SUCCESS: server-add 165.225.185.12:8091
</code></p>

<p>To verify it was added, run:</p>

<p><code>
$ docker run --rm --entrypoint=/opt/couchbase/bin/couchbase-cli couchbase/server \
server-list -c $container_1_ip \
-u Administrator -p password
</code></p>

<p>which should return the list of Couchbase Server nodes that are now part of the cluster:</p>

<p><code>
ns_1@165.225.185.11 165.225.185.11:8091 healthy active
ns_1@165.225.185.12 165.225.185.12:8091 healthy inactiveAdded
</code></p>

<h3>Add 3rd Couchbase node and rebalance</h3>

<p>In this step we will:</p>

<ul>
<li>Add the 3rd Couchbase node</li>
<li>Trigger a &ldquo;rebalance&rdquo;, which distributes the (empty) bucket&rsquo;s data across the cluster</li>
</ul>


<p><code>
$ docker run --rm --entrypoint=/opt/couchbase/bin/couchbase-cli couchbase/server \
rebalance -c $container_1_ip \
-u Administrator -p password \
--server-add $container_3_ip \
--server-add-username Administrator \
--server-add-password password
</code></p>

<p>You should see:</p>

<p>```
INFO: rebalancing &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip;
SUCCESS: rebalanced cluster
close failed in file object destructor:
Error in sys.excepthook:</p>

<p>Original exception was:
```</p>

<p>If you see <strong>SUCCESS</strong>, then it worked.  <em>(I&rsquo;m not sure why the &ldquo;close failed in file ..&rdquo; error is happening, but so far it appears that it can be safely ignored.)</em></p>

<h3>Login to Web UI</h3>

<p>Open your browser to $container_1_ip:8091 and you should see:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/couchbase_cluster_login.png" alt="Couchbase Login Screen" /></p>

<p>Login with:</p>

<ul>
<li>Username: <strong>Administrator</strong></li>
<li>Password: <strong>password</strong></li>
</ul>


<p>And you should see:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/couchbase_cluster_nodes.png" alt="Couchbase Nodes" /></p>

<p>Congratulations!  You have a Couchbase Server cluster up and running on Joyent Triton.</p>

<h2>Teardown</h2>

<p>To stop and remove your Couchbase server containers, run:</p>

<p><code>
$ docker stop $container_1 $container_2 $container_3
$ docker rm $container_1 $container_2 $container_3
</code></p>

<p>To double check that you no longer have any containers running or in the stopped state, run <code>docker ps -a</code> and you should see an empty list.</p>

<h2>Installing the SDC tools (optional)</h2>

<p>Installing the Joyent Smart Data Center (SDC) tools will allow you to gain more visibility into your container cluster &mdash; for example being able to view the internal IP of each continer.</p>

<p>Here&rsquo;s how to install the sdc-tools suite.</p>

<h3>Install smartdc</h3>

<p>First <a href="http://coolestguidesontheplanet.com/installing-node-js-on-osx-10-10-yosemite/">install NodeJS + NPM</a></p>

<p>Install smartdc:</p>

<p><code>
npm install -g smartdc
</code></p>

<h3>Configure environment variables</h3>

<p><code>
$ export SDC_URL=https://us-east-3b.api.joyent.com
$ export SDC_ACCOUNT=&lt;ACCOUNT&gt;
$ export SDC_KEY_ID=$(ssh-keygen -l -f $HOME/.ssh/id_rsa.pub | awk '{print $2}')
</code></p>

<p>Replace values as follows:</p>

<ul>
<li><strong>ACCOUNT</strong>: you can get this by logging into the Joyent web ui and going to the Account menu from the pulldown in the top-right corner.  Find the <strong>Username</strong> field, and use that</li>
</ul>


<h3>List machines</h3>

<p>Run <code>sdc-listmachines</code> to list all the containers running under your Joyent account.  Your output should look something like this:</p>

<p>```
$ sdc-listmachines
[
{</p>

<pre><code>"id": "0c6f8ca2-9514-48e4-97d7-e12026dcae4a",
"name": "couchbase-server-3",
"type": "smartmachine",
"state": "running",
"image": "335a8046-0749-1174-5666-6f084472b5ef",
"ips": [
  "192.168.128.32",
  "165.225.185.13"
],
"memory": 1024,
"disk": 25600,
"metadata": {},
"tags": {},
"created": "2015-03-26T14:50:31.196Z",
"updated": "2015-03-26T14:50:45.000Z",
"networks": [
  "7cfe29d4-e313-4c3b-a967-a28ea34342e9",
  "178967cb-8d11-4f53-8434-9c91ff819a0d"
],
"dataset": "335a8046-0749-1174-5666-6f084472b5ef",
"primaryIp": "165.225.185.13",
"firewall_enabled": false,
"compute_node": "44454c4c-4400-1046-8050-b5c04f383432",
"package": "t4-standard-1G"
</code></pre>

<p>  },
]
```</p>

<h3>Find private IP of an individual machine</h3>

<p><code>
$ sdc-getmachine &lt;machine_id&gt; | json -aH ips | json -aH | egrep "10\.|192\.”
</code></p>

<h2>References</h2>

<ul>
<li><p><a href="https://github.com/joyent/sdc-docker/blob/master/docs/divergence.md">Native Docker API vs Joyent Triton API</a></p></li>
<li><p><a href="https://www.joyent.com/blog/container-service-preview">https://www.joyent.com/blog/container-service-preview</a></p></li>
<li><p><a href="https://www.joyent.com/blog/docker-bake-off-aws-vs-joyent">https://www.joyent.com/blog/docker-bake-off-aws-vs-joyent</a></p></li>
<li><p><a href="https://github.com/joyent/sdc-docker">https://github.com/joyent/sdc-docker</a></p></li>
<li><p><a href="https://github.com/joyent/sdc-docker/blob/master/docs/divergence.md">https://github.com/joyent/sdc-docker/blob/master/docs/divergence.md</a></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
