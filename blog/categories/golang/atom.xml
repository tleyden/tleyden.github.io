<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | Seven Story Rabbit Hole]]></title>
  <link href="http://tleyden.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://tleyden.github.io/"/>
  <updated>2016-02-07T17:18:37+00:00</updated>
  <id>http://tleyden.github.io/</id>
  <author>
    <name><![CDATA[Traun Leyden]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Configure Emacs as a Go Editor From Scratch Part 3]]></title>
    <link href="http://tleyden.github.io/blog/2016/02/07/configure-emacs-as-a-go-editor-from-scratch-part-3/"/>
    <updated>2016-02-07T04:25:00+00:00</updated>
    <id>http://tleyden.github.io/blog/2016/02/07/configure-emacs-as-a-go-editor-from-scratch-part-3</id>
    <content type="html"><![CDATA[<p>This is a continuation from <a href="http://tleyden.github.io/blog/2014/05/27/configure-emacs-as-a-go-editor-from-scratch-part-2/">a previous blog post</a>.  In this post I&rsquo;m going to focus on making emacs look a bit better.</p>

<p>Currently:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/emacs_ugly.png" alt="screenshot" /></p>

<h2>Install a nicer theme</h2>

<p>I like the <code>taming-mr-arneson-theme</code>, so let&rsquo;s install that one.  Feel free to browse the emacs themes and find one that you like more.</p>

<p><code>
$ `mkdir ~/.emacs.d/color-themes`
$ `wget https://raw.githubusercontent.com/emacs-jp/replace-colorthemes/d23b086141019c76ea81881bda00fb385f795048/taming-mr-arneson-theme.el`
</code></p>

<p>Update your <code>~/emacs.d/init.el</code> to add the following lines to the top of the file:</p>

<p><code>
(add-to-list 'custom-theme-load-path "/Users/tleyden/.emacs.d/color-themes/")
(load-theme 'taming-mr-arneson t)
</code></p>

<p>Now when you restart emacs it should look like this:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/emacs_taming_mr_arneson.png" alt="screenshot" /></p>

<p> ## Directory Tree</p>

<p><code>
$ cd ~/DevLibraries
$ git clone https://github.com/jaypei/emacs-neotree.git neotree
</code></p>

<p>Update your <code>~/emacs.d/init.el</code> to add the following lines:</p>

<p><code>
(add-to-list 'load-path "/some/path/neotree")
(require 'neotree)
</code></p>

<p>Open a <code>.go</code> file and the enter <code>M-x neotree-dir</code> to show a directory browser:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/emacs-neotree.png" alt="screnshot" /></p>

<p>Ref: <a href="http://www.emacswiki.org/emacs/NeoTree">NeoTree</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test coverage for Go with drone.io and coveralls.io]]></title>
    <link href="http://tleyden.github.io/blog/2015/03/31/test-coverage-for-go-with-drone-dot-io-and-coveralls-dot-io/"/>
    <updated>2015-03-31T07:26:00+00:00</updated>
    <id>http://tleyden.github.io/blog/2015/03/31/test-coverage-for-go-with-drone-dot-io-and-coveralls-dot-io</id>
    <content type="html"><![CDATA[<p>This will walk you through setting up a test coverage report on coveralls.io which will be updated every time a new build happens on drone.io (a continuous integration server similar to TavisCI).</p>

<p>I&rsquo;m going to use the <a href="https://github.com/couchbaselabs/sg-replicate">couchbaselabs/sg-replicate</a> repo as an example, since it currently does not have any test coverage statistics.  The goal is to end up with a badge in the README that points to a test coverage report hosted on coveralls.io.</p>

<h2>Clone the repo</h2>

<p><code>
$ git clone https://github.com/couchbaselabs/sg-replicate.git
$ cd sg-replicate
</code></p>

<h2>Test coverage command line stats</h2>

<p>```
$ go test -cover
go tool: no such tool &ldquo;cover&rdquo;; to install:</p>

<pre><code>go get golang.org/x/tools/cmd/cover
</code></pre>

<p>```</p>

<p>Try again:</p>

<p><code>
$ go get golang.org/x/tools/cmd/cover &amp;&amp; go test -cover
PASS
coverage: 69.4% of statements
ok      github.com/couchbaselabs/sg-replicate   0.156s
</code></p>

<p>Ouch, 69.4% is barely a C-. (if you round up!)</p>

<h2>Coverage breakdown</h2>

<p>Text report:</p>

<p><code>
$ go test -coverprofile=coverage.out
$ go tool cover -func=coverage.out
github.com/couchbaselabs/sg-replicate/attachment.go:15:         NewAttachment           84.6%
github.com/couchbaselabs/sg-replicate/changes_feed_parameters.go:20:    NewChangesFeedParams        100.0%
github.com/couchbaselabs/sg-replicate/changes_feed_parameters.go:30:    FeedType            100.0%
github.com/couchbaselabs/sg-replicate/changes_feed_parameters.go:34:    Limit               100.0%
</code></p>

<p>HTML report:</p>

<p><code>
$ go test -coverprofile=coverage.out
$ go tool cover -html=coverage.out
</code></p>

<p>This should open up the following report in your default browser:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/go_coverage_html.png" alt="html report" /></p>

<h2>Coveralls.io setup</h2>

<ul>
<li>Login to coveralls.io</li>
<li>Create a new repo</li>
<li>Get the repo token from the <strong>SET UP COVERALLS</strong> section</li>
</ul>


<p>At this point, your empty coveralls repo will look something like this:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/coveralls_empty_repo.png" alt="empty coveralls repo" /></p>

<h2>Configure Drone.io + Goveralls</h2>

<p>If you have not already done so, setup a drone.io build for your repo.</p>

<p>On the drone.io <strong>Settings</strong> page, make the following changes:</p>

<p><strong>Environment Variables</strong></p>

<p>In the Environment Variables section of the web ui, add:</p>

<p><code>
COVERALLS_TOKEN=&lt;coveralls_repo_token&gt;
</code></p>

<p><strong>Commands</strong></p>

<p>In the commands section, you can replace your existing <code>go test</code> call with:</p>

<p><code>
go get github.com/axw/gocov/gocov
go get github.com/mattn/goveralls
goveralls -service drone.io -repotoken $COVERALLS_TOKEN
</code></p>

<p>Here&rsquo;s what it should look like:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/drone_io_coverage.png" alt="drone io ui" /></p>

<h2>Kick off a build</h2>

<p>Go to the drone.io project page for your repo, and hit <strong>Build Now</strong></p>

<p>At the bottom of the build output, you should see:</p>

<p><code>
Job #1.1
https://coveralls.io/jobs/5189501
</code></p>

<p>If you follow the link, you should see something like:</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/coveralls_sgreplicate.png" alt="coveralls report" /></p>

<p>Looks like we just went from a C- to a B!  I have no idea why the coverage improved, but I&rsquo;ll take it.</p>

<h2>Add a badge, call it a day</h2>

<p>On the coveralls.io project page for your repo, you should see a button near the top called <strong>Badge URLS</strong>.  Click and copy/paste the markdown, which should look something like this:</p>

<p><code>
[![Coverage Status](https://coveralls.io/repos/couchbaselabs/sg-replicate/badge.svg?branch=master)](https://coveralls.io/r/couchbaselabs/sg-replicate?branch=master)
</code></p>

<p>And add it to your project&rsquo;s README.</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/sg_replicate_badges.png" alt="badges" /></p>

<h2>References</h2>

<ul>
<li><a href="https://blog.golang.org/cover">https://blog.golang.org/cover</a></li>
<li><a href="https://github.com/mattn/goveralls">https://github.com/mattn/goveralls</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting started with Go and Protocol Buffers]]></title>
    <link href="http://tleyden.github.io/blog/2014/12/02/getting-started-with-go-and-protocol-buffers/"/>
    <updated>2014-12-02T06:32:00+00:00</updated>
    <id>http://tleyden.github.io/blog/2014/12/02/getting-started-with-go-and-protocol-buffers</id>
    <content type="html"><![CDATA[<p>I found the <a href="https://github.com/golang/protobuf">official docs</a> on using Google Protocol Buffers from Go a bit confusing, and couldn&rsquo;t find any other clearly written blog posts on the subject, so I figured I&rsquo;d write my own.</p>

<p>This will walk you through the following:</p>

<ul>
<li>Install golang/protobuf and required dependencies</li>
<li>Generating Go wrappers for a test protocol buffer definition</li>
<li>Using those Go wrappers to marshal and unmarshal an object</li>
</ul>


<h2>Install protoc binary</h2>

<p>Since the protocol buffer compiler <code>protoc</code> is required later, we must install it.</p>

<p><strong>Ubuntu 14.04</strong></p>

<p>If you want to use an older version (v2.5), simply do:</p>

<p><code>
$ apt-get install protobuf-compiler
</code></p>

<p>Otherwise if you want the latest version (v2.6):</p>

<p><code>
$ apt-get install build-essential
$ wget https://protobuf.googlecode.com/svn/rc/protobuf-2.6.0.tar.gz
$ tar xvfz protobuf-2.6.0.tar.gz
$ cd protobuf-2.6.0
$ ./configure &amp;&amp; make install
</code></p>

<p><strong>OSX</strong></p>

<p><code>
$ brew install protobuf
</code></p>

<h2>Install Go Protobuf library</h2>

<p>This assumes you have Go 1.2+ or later already installed, and your <code>$GOPATH</code> variable set.</p>

<p>In order to generate Go wrappers, we need to install the following:</p>

<p><code>
$ go get -u -v github.com/golang/protobuf/proto
$ go get -u -v github.com/golang/protobuf/protoc-gen-go
</code></p>

<h2>Download a test .proto file</h2>

<p>In order to generate wrappers, we need a <code>.proto</code> file with object definitions.</p>

<p>This one is a slightly modified version of the one from the <a href="https://github.com/golang/protobuf">official docs</a>.</p>

<p><code>
$ wget https://gist.githubusercontent.com/tleyden/95de4bfe34321c79e91b/raw/f8696fe0f1462f377d6bd13c5f20cccfa182578a/test.proto
</code></p>

<h2>Generate Go wrappers</h2>

<p><code>
$ protoc --go_out=. *.proto
</code></p>

<p>You should end up with a new file generated: <code>test.pb.go</code></p>

<h2>Marshalling and unmarshalling an object</h2>

<p>Open a new file <code>main.go</code> in <a href="http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scratch/">emacs</a> or your favorite editor, and paste the following:</p>

<p>```
package main</p>

<p>import (</p>

<pre><code>"log"

"github.com/golang/protobuf/proto"
</code></pre>

<p>)</p>

<p>func main() {</p>

<pre><code>test := &amp;Test{
    Label: proto.String("hello"),
    Type:  proto.Int32(17),
    Optionalgroup: &amp;Test_OptionalGroup{
        RequiredField: proto.String("good bye"),
    },
}
data, err := proto.Marshal(test)
if err != nil {
    log.Fatal("marshaling error: ", err)
}
newTest := &amp;Test{}
err = proto.Unmarshal(data, newTest)
if err != nil {
    log.Fatal("unmarshaling error: ", err)
}
// Now test and newTest contain the same data.
if test.GetLabel() != newTest.GetLabel() {
    log.Fatalf("data mismatch %q != %q", test.GetLabel(), newTest.GetLabel())
}

log.Printf("Unmarshalled to: %+v", newTest)
</code></pre>

<p>}
```</p>

<p>Explanation:</p>

<ul>
<li>Lines 11-14: Create a new object suitable for protobuf marshalling and populate it&rsquo;s fields.  <em>Note that using <code>proto.String(..)</code> / <code>proto.Int32(..)</code> isn&rsquo;t strictly required, they are just convencience wrappers to get string / int pointers</em>.</li>
<li>Line 18: Marshal to a byte array.</li>
<li>Line 22: Create a new empty object.</li>
<li>Line 23: Unmarshal previously marshalled byte array into new object</li>
<li>Line 28: Verify that the &ldquo;label&rdquo; field made the marshal/unmarshall round trip safely</li>
</ul>


<p><strong>Run it via:</strong></p>

<p><code>
$ go run main.go test.pb.go
</code></p>

<p>and you should see the output:</p>

<p><code>
Unmarshalled to: label:"hello" type:17 OptionalGroup{RequiredField:"good bye" }
</code></p>

<p>Congratulations!  You are now using protocol buffers from Go.</p>

<h2>References</h2>

<ul>
<li><a href="https://github.com/golang/protobuf">Official golang/protobuf repo</a></li>
<li><a href="https://code.google.com/p/gogoprotobuf/">gogoprotobuf fork</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An example of using NSQ from Go]]></title>
    <link href="http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/"/>
    <updated>2014-11-12T07:26:00+00:00</updated>
    <id>http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/bitly/nsq">NSQ</a> is a message queue, similar to RabbitMQ.  I decided I&rsquo;d give it a whirl.</p>

<h2>Install Nsq</h2>

<p><code>
$ wget https://s3.amazonaws.com/bitly-downloads/nsq/nsq-0.2.31.darwin-amd64.go1.3.1.tar.gz
$ tar xvfz nsq-0.2.31.darwin-amd64.go1.3.1.tar.gz
$ sudo mv nsq-0.2.31.darwin-amd64.go1.3.1/bin/* /usr/local/bin
</code></p>

<h2>Launch Nsq</h2>

<p><code>
$ nsqlookupd &amp;
$ nsqd --lookupd-tcp-address=127.0.0.1:4160 &amp;
$ nsqadmin --lookupd-http-address=127.0.0.1:4161 &amp;
</code></p>

<h2>Get Go client library</h2>

<p><code>
$ go get -u -v github.com/bitly/go-nsq
</code></p>

<h2>Create a producer</h2>

<p>Add the following code to main.go:</p>

<p>```
package main</p>

<p>import (</p>

<pre><code>"log"
"github.com/bitly/go-nsq"
</code></pre>

<p>)</p>

<p>func main() {</p>

<pre><code>config := nsq.NewConfig()
w, _ := nsq.NewProducer("127.0.0.1:4150", config)

err := w.Publish("write_test", []byte("test"))
if err != nil {
    log.Panic("Could not connect")
}

w.Stop()
</code></pre>

<p>}</p>

<p>```</p>

<p>and then run it with:</p>

<p><code>
$ go run main.go
</code></p>

<p>If you go to your NSQAdmin at <a href="http://localhost:4171/">http://localhost:4171</a>, you should see a single message in the <code>write_test</code> topic.</p>

<p><img src="http://tleyden-misc.s3.amazonaws.com/blog_images/nsq_admin.png" alt="NSQAdmin" /></p>

<h2>Create a consumer</h2>

<p>```
package main</p>

<p>import (</p>

<pre><code>"log"
"sync"

"github.com/bitly/go-nsq"
</code></pre>

<p>)</p>

<p>func main() {</p>

<pre><code>wg := &amp;sync.WaitGroup{}
wg.Add(1)

config := nsq.NewConfig()
q, _ := nsq.NewConsumer("write_test", "ch", config)
q.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
    log.Printf("Got a message: %v", message)
    wg.Done()
    return nil
}))
err := q.ConnectToNSQD("127.0.0.1:4150")
if err != nil {
    log.Panic("Could not connect")
}
wg.Wait()
</code></pre>

<p>}</p>

<p>```</p>

<p>and then run it with:</p>

<p><code>
$ go run main.go
</code></p>

<p>You should see output:</p>

<p><code>
2014/11/12 08:37:29 INF    1 [write_test/ch] (127.0.0.1:4150) connecting to nsqd
2014/11/12 08:37:29 Got a message: &amp;{[48 55 54 52 48 57 51 56 50 100 50 56 101 48 48 55] [116 101 115 116] 1415810020571836511 2 0xc208042118 0 0}
</code></p>

<p>Congratulations!  You just pushed a message through <strong>NSQ</strong>.</p>

<h2>Enhanced consumer: use NSQLookupd</h2>

<p>The above example hardcoded the ip of <code>nsqd</code> into the consumer code, which is not a best practice.  A better way to go about it is to point the consumer at <code>nsqlookupd</code>, which will transparently connect to the appropriate <code>nsqd</code> that happens to be publishing that topic.</p>

<p>In our example, we only have a single <code>nsqd</code>, so it&rsquo;s an extraneous lookup.  But it&rsquo;s good to get into the right habits early, especially if you are a <em>habitual copy/paster</em>.</p>

<p>The consumer example only needs a one-line change to get this enhancement:</p>

<p><code>
err := q.ConnectToNSQLookupd("127.0.0.1:4161")
</code></p>

<p>Which will connect to the HTTP port of <code>nsqlookupd</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goroutines vs Threads]]></title>
    <link href="http://tleyden.github.io/blog/2014/10/30/goroutines-vs-threads/"/>
    <updated>2014-10-30T06:28:00+00:00</updated>
    <id>http://tleyden.github.io/blog/2014/10/30/goroutines-vs-threads</id>
    <content type="html"><![CDATA[<p>Here are some of the advantages of Goroutines over threads:</p>

<ul>
<li>You can run more goroutines on a typical system than you can threads.</li>
<li>Goroutines have growable segmented stacks.</li>
<li>Goroutines have a faster startup time than threads.</li>
<li>Goroutines come with built-in primitives to communicate safely between themselves (channels).</li>
<li>Goroutines allow you to avoid having to resort to mutex locking when sharing data structures.</li>
<li>Goroutines are multiplexed onto a small number of OS threads, rather than a 1:1 mapping.</li>
<li>You can write massively concurrent servers withouth having to resort to evented programming.</li>
</ul>


<h2>You can run more of them</h2>

<p>On Java you can run 1000&rsquo;s or tens of 1000&rsquo;s threads.  On Go you can run hundreds of thousands or millions of goroutines.</p>

<p>Java threads map directly to OS threads, and are relatively heavyweight.  Part of the reason they are heavyweight is their rather large fixed stack size.  This caps the number of them you can run in a single VM due to the increasing memory overhead.</p>

<p>Go OTOH has a segmented stack that grows as needed.  They are &ldquo;Green threads&rdquo;, which means the Go runtime does the scheduling, not the OS.  The runtime multiplexes the goroutines onto real OS threads, the number of which is controlled by <code>GOMAXPROCS</code>.  Typically you&rsquo;ll want to set this to the number of cores on your system, to maximize potential parellelism.</p>

<h2>They let you avoid locking hell</h2>

<p>One of the biggest drawback of threaded programming is the complexity and brittleness of many codebases that use threads to achieve high concurrency.  There can be latent deadlocks and race conditions, and it can become near impossible to reason about the code.</p>

<p>Go OTOH gives you primitives that allow you to avoid locking completely.  The mantra is <em>don&rsquo;t communicate by sharing memory, share memory by communicating</em>.  In other words, if two goroutines need to share data, they can do so safely over a channel.  Go handles all of the synchronization for you, and it&rsquo;s much harder to run into things like deadlocks.</p>

<h2>No callback spaghetti, either</h2>

<p>There are other approaches to achieving high concurrency with a small number of threads.  Python Twisted was one of the early ones that got a lot of attention.  Node.js is currently the most prominent evented frameworks out there.</p>

<p>The problem with these evented frameworks is that the code complexity is also high, and difficult to reason about.  Rather than &ldquo;straightline&rdquo; coding, the programmer is forced to chain callbacks, which gets interleaved with error handling.  While refactoring can help tame some of the mental load, it&rsquo;s still an issue.</p>
]]></content>
  </entry>
  
</feed>
